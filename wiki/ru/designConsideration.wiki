#summary Design guide

= Введение =
[http://static.springsource.org/spring-security/site/ Spring Security] используется для аутентификации и авторизации, в тех случаях когда происходит исключение системы безопасности,
В случае работы с GWT, у вас есть два способа корректно работать с исключениями системы безопасности,
  # предоставить стандартную страницу аутентификации с http-формой,
  # или самостоятельно обработать исключения в GWT. 

Gwtsecurity перехватывает запросы к приложению на уровне обращений к фрэймворку Spring Security (используя AOP), <br/>
gwtsecury определяет источник исключения, был ли это RemoteService или исключение было брошено в Spring MVC.<br/>
Если запрос пришедший во фрэймворк был предназначен RemoteService, то gwtsecurity разбирает пришедший запрос и передает его во внутренние механизмы Spring Security. <br/>
Если результатом является исключение то библиотека трансформирует исключение в [http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/exceptions/GwtSecurityException.html GwtSecurityException] которое пробрасывается на клиенсткую сторону GWT,<br/>
если же запрос был направлен не RemoteService gwtsecurity передает запрос через стандартный механизм Spring Security.


= Подробнее =
В первую очередь, нужно добавить AOP в конфигурацию Spring ващего приложения следующим образом.<br/>
(Включение proxy-target-class значительно увеличивает скорость обработки запросов средствами AOP.)
{{{
    <aop:aspectj-autoproxy proxy-target-class="true"/>
}}}
после этого добавьте в конфигурацию бин отвечающий за трансляцию эксепшенов в стандартной модели работы Spring Security [http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/GwtExceptionTranslator.html GwtExceptionTranslator].
{{{
    <beans:bean class="com.gwt.ss.GwtExceptionTranslator"/>
}}}

Gwtsecurity предлагает два типа исключений безопасности [http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/exceptions/GwtSecurityException.html GwtSecurityException].
|| [http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/exceptions/GwtAuthenticationException.html GwtAuthenticationException] || в случае если пользователь не аутентифицирован.<br>, в этом случае GWT приложение должно предоставить пользователю форсу для введение данных для аутентификации. ||
|| [http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/exceptions/GwtAccessDeniedException.html GwtAccessDeniedException] || в случае если пользователь не имеет достаточных прав для доступа к ресурсу.<br/>в этом случае, пользователь должен получить предупреждение об этом. ||

В демо-приложении, производится перехват ислючений безопасности и обработка исключени самим приложением (так же предоставляется возможность аутентификации через стандартную http-форму).
|| Аутентификация средствами GWT RPC если пользователь не аутентифицирован||
|| [http://gwtsecurity.googlecode.com/svn/resources/gssdemoSimpleLogin.png] ||
|| или редирект на стандартную http-форму логина (jsp page) ||
|| [http://gwtsecurity.googlecode.com/svn/resources/login_jsp.png] ||


Конфигурация spring secutiry делается следующим образом:<br/>
В первую очередь, определяется путь к странице с http-формой для логина которая будет обрабатывать не GWT запросы.
{{{
   <form-login login-page="/login.jsp" authentication-failure-url="/login.jsp?authfailed=true"/>
}}}
Далее, создается бин для перехвата и обработки запросов на аутентификацию:
{{{
   <beans:bean class="com.gwt.ss.GwtUsernamePasswordAuthority">
       <beans:property name="authenticationManager" ref="authenticationManager"/>
   </beans:bean>
}}}
И наконец, для аутентификации необходимо использовать предоставлявляемый RemoteService для аутентификации пользователя.
{{{
    GwtLoginAsync loginService = GwtLoginAsync.Util.getInstance(getLoginUrl());
    loginService.j_gwt_security_check(userName, password, new AsyncCallback<Void>() {
        @Override
        public void onFailure(Throwable caught) {
           //fail notify 
        }
        @Override                          
        public void onSuccess(Void result) {
           //success notify
        }
    }
}}}
Таким же образом мы можем сконфигурировать приложение для выхода пользователей из системы.<br/>
(сконфигурируйте success-handler-ref для выхода пользователей из системы logout-success-url вместо стандартного.)
{{{
    <logout invalidate-session="true" success-handler-ref="logoutSuccessHandler" logout-url="/j_spring_security_logout"/>
    <beans:bean id="logoutSuccessHandler" class="com.gwt.ss.GwtLogoutSuccessHandler" p:logoutSuccessUrl="/"/>
}}}
После этого можно использовать предоставлявляемый RemoteService для выходя пользователя из системыю
{{{
    GwtLogoutAsync logoutService = GwtLogoutAsync.Util.getInstance(getLogoutUrl());
    logoutService.j_gwt_security_logout(new AsyncCallback<Void>() {
        @Override
        public void onFailure(Throwable caught) {
            //fail notify
        }                
        @Override
        public void onSuccess(Void result) {
           //success notify
        }
    }
}}}
В качестве альтернативы можно использовать путь "http://context_path/j_spring_security_logout"

В случае необходимости вы можете использовать управление сессиями "session-management"
{{{
    <session-management invalid-session-url="/login.jsp?sessionInvalid=true">
        <concurrency-control max-sessions="1" expired-url="/login.jsp?sessionExpired=true"/>
    </session-management>
}}}
После этого вы можете создать бин [http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/GwtSessionManagement.html GwtSessionManagement]
который будет бросать исключение [http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/exceptions/GwtAccessDeniedException.html GwtAccessDeniedException] если сессия не является валидной.
<br/><span color="red">(Замечание: ранее заданое свойство proxy-target-class должно быть установлено в "false")</span>
{{{
    <beans:bean class="com.gwt.ss.GwtSessionManagement"/>
}}}