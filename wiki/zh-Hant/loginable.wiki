#summary Make asynchronous remote call loginable

= Introduction =
[http://code.google.com/p/gwtsecurity/ GwtSecurity] 通知您的在PRC函式發生Spring Security 錯誤,
然後您必須進行登錄後再發送一次遠端程序叫用。

隨著程式愈來愈大，無聊的代碼一再地重覆，讓我來告訴您如何避免這些煩人的工作。

= Details =
最開始, 你的遠端服務方法宣告[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/GwtSecurityException.html GwtSecurityException]
以通告主機端可能發生的安全性事務錯誤
{{{
    public interface RemoteCall extends RemoteService {
        RtnType request(ParamType param) throws GwtSecurityException;
    }
}}}

接著您定義另一個配對的 interface，

{{{
    public interface RemoteCallAsync{
        void request(ParamType parameter, AsyncCallback<RtnType> callback);
    }
}}}

然後建立RemoteCallAsync以進行遠端程序叫用

{{{
   RemoteCallAsync rc = (RemoteCallAsync) GWT.create(RemoteCall.class);  
}}}

您撰寫函式並自行控制錯誤處理

{{{
   rc.request(param,new AsyncCallback<RtnType>(){
       @Override
       public void onFailure(Throwable caught) {
          //此時您必須準備一個登錄的界面,
          //當用戶登錄成功時，重新再一次發送需求,
          //或者思考用戶中斷登錄時該怎麼處理。
       }
       @Override
       public void onSuccess(RtnType result) {
       }
   });
}}}

我覺得自行進行錯錯控制處理並不是一件容易的事。
所以在1.0.3版以後，我加入了[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/loginable/package-summary.html loginable]模組.

現在，您非同步遠端叫用的配對Interface必須實做[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/loginable/LoginableAsync.html LoginableAsync]

{{{
    public interface RemoteCallAsync extends LoginableAsync{
        void request(ParamType parameter, AsyncCallback<RtnType> callback);
    }
}}}

並且寫好一個實做[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/loginable/HasLoginHandler.html HasLoginHandler]的[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/loginable/AbstractLoginBox.html 登錄對話方塊]
以處理以下兩件事. 
  # 當叫用[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/loginable/HasLoginHandler.html#startLogin(java.lang.Throwable) startLogin]時進行登錄作業
  # 無論登錄成功或取消，都得觸發一個[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/loginable/LoginEvent.html LoginEvent]。

接著，讓 GwtSecurity 為您的非同步interface建立一個代理包裝物件。

{{{
    RemoteCallAsync proxy = GWT.create(RemoteCallAsync.class);
}}}

實際上 proxy 為一[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/loginable/LoginableService.html LoginableService] 物件。
必須為它指定RemoteService物件與[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/loginable/AbstractLoginBox.html 登錄對話方塊].
{{{
    LoginableService<RemoteCallAsync> loginService = (LoginableService<RemoteCallAsync>) proxy;
    //建立Remote Service
    RemoteCallAsync remoteService = (RemoteCallAsync) GWT.create(RemoteCall.class);
    //指定Remote Service
    loginService.setRemoteService(remoteService);
    //指定登錄對話方塊
    loginService.setHasLoginHandler(loginbox);
}}}

現在您使用此proxy物件如同之前使用RemoteCallAsync一般，而無須擔憂安全性事務錯誤<br/>
因為當安全性事務錯誤發生時，proxy物件會啟始登錄程序。
如果登錄成功，同樣的函式會再發送一次。
否則，當用戶取消登錄時，您則必須處理[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/loginable/LoginCancelException.html LoginCancelException]。

現在，以下還有一個不尋常的議題: 兩個連續的遠端叫用。

{{{
    public void doDiscreteRequests(){
        asyncProxy.request1(param... ,new AsyncCallBack<?> callback(){
           ....
        });
        asyncProxy.request2(param... ,new AsyncCallBack<?> callback(){
           ....
        });
    }
}}}

我們都理解，兩個遠端叫用皆為非同步，且各自獨立不會因為前一個發生異常而影響到下一個函式地叫用。
所以有可能會叫用startLogin() 兩次.

對於解決的方式，我的建議是:

LoginBox當為 singleton 模式，且該登錄對話方塊能應付stargLogin()多次叫用仍顯示同一個登錄畫面。

因為proxy物件會對LoginBox註冊事件處理。<br/>
所以當登錄成功時，兩個函式都會再次發送，<br/>
否則兩個函式各自的錯誤處理就都必須處理[http://gwtsecurity.googlecode.com/svn/javadoc/latest/com/gwt/ss/client/loginable/LoginCancelException.html LoginCancelException]。 