#summary 設計說明

= 前言 =
[http://static.springsource.org/spring-security/site/ Spring Security ] 在發生安全性事務錯誤,要求要有一個登錄點
以GWT來說, 有兩種處理方式, 
  # 提供一個獨立的登錄頁面, 
  # 或者直接在GWT內處理 

Gwtsecurity 對Sprign Security的事件加以監聽, 當安全錯誤發生時, <br/>
gwtsecury 會判斷對事件發生的主體是不是來自RemoteService，<br/>
如果是, gwtsecurity 會直接回報[http://code.google.com/p/gwtsecurity/source/browse/trunk/gwtsecurity/src/main/java/com/gwt/ss/client/GwtSecurityException.java GwtSecurityException]給GWT程式, 
<br/>否則按照原來的Spring Security機制處置。


= 說明 =
首先,設定檔須加入使用aop名稱空間，並啟用以下設定.<br/>
(啟用proxy-target-class 速度較快.)
{{{
    <aop:aspectj-autoproxy proxy-target-class="true"/>
}}}
然後建立[http://gwtsecurity.googlecode.com/svn/trunk/javadoc/1.0.3/com/gwt/ss/GwtExceptionTranslator.html GwtExceptionTranslator] bean 來處理安全性事務異常.
{{{
    <beans:bean class="com.gwt.ss.GwtExceptionTranslator"/>
}}}

Gwtsecurity 提供兩類錯誤 [http://gwtsecurity.googlecode.com/svn/trunk/javadoc/1.0.3/com/gwt/ss/client/GwtSecurityException.html GwtSecurityException].
|| [http://gwtsecurity.googlecode.com/svn/trunk/javadoc/1.0.3/com/gwt/ss/client/GwtAuthenticationException.html GwtAuthenticationException] || 意謂尚未對用戶加以認證.<br>, GWT程式有責任引導用戶登錄。 ||
|| [http://gwtsecurity.googlecode.com/svn/trunk/javadoc/1.0.3/com/gwt/ss/client/GwtAccessDeniedException.html GwtAccessDeniedException] || 意謂用戶權限不足以存取該資源.<br/>此時必須對用戶加以警告。 ||

在範例程式中, 我的處理方式是交由GWT程式本身來處理(我也提供了一個獨立的登錄頁)：
|| Gwt 處理未登錄用戶||                                                                           
|| [http://gwtsecurity.googlecode.com/svn/trunk/resources/gssdemoSimpleLogin.png] ||
|| 或者導到另一個頁面(jsp) ||
|| [http://gwtsecurity.googlecode.com/svn/trunk/resources/login_jsp.png] ||

我的設定如下：
首先,我設定spring處理非GWT程式頁面所需的登錄點. 
{{{
   <form-login login-page="/login.jsp" authentication-failure-url="/login.jsp?authfailed=true"/>
}}}
然後建立以下Bean來處理Gwt rpc登錄:
{{{
   <beans:bean class="com.gwt.ss.GwtUsernamePasswordAuthority">
       <beans:property name="authenticationManager" ref="authenticationManager"/>
   </beans:bean>
}}}
最後使用RemoteService進行登錄.
{{{
    GwtLoginAsync loginService = GwtLoginAsync.Util.getInstance(getLoginUrl());
    loginService.j_gwt_security_check(userName, password, new AsyncCallback<Void>() {
        @Override
        public void onFailure(Throwable caught) {
           //錯誤通知 
        }
        @Override
        public void onSuccess(Void result) {
           //成功通知
        }
    }
}}}
同樣地方式也可以用來處理Gwt登出<br/>
(使用success-handler-ref設定取代logout-success-url.)
{{{
    <logout invalidate-session="true" success-handler-ref="logoutSuccessHandler" logout-url="/j_spring_security_logout"/>
    <beans:bean id="logoutSuccessHandler" class="com.gwt.ss.GwtLogoutSuccessHandler" p:logoutSuccessUrl="/"/>
}}}
最後
{{{
    GwtLogoutAsync logoutService = GwtLogoutAsync.Util.getInstance(getLogoutUrl());
    logoutService.j_gwt_security_logout(new AsyncCallback<Void>() {
        @Override
        public void onFailure(Throwable caught) {
            //錯誤通知
        }                
        @Override
        public void onSuccess(Void result) {
           //成功通知
        }
    }
}}}
另外，從"http://context_path/j_spring_security_logout"路徑登出也是一種選項 

在有些時候, 您也許想要設定"session-management"
{{{
    <session-management invalid-session-url="/login.jsp?sessionInvalid=true">
        <concurrency-control max-sessions="1" expired-url="/login.jsp?sessionExpired=true"/>
    </session-management>
}}}
此時您需要建立[http://gwtsecurity.googlecode.com/svn/trunk/javadoc/1.0.3/com/gwt/ss/GwtSessionManagement.html GwtSessionManagement]，
以便在Session逾期時能發出[http://gwtsecurity.googlecode.com/svn/trunk/javadoc/1.0.3/com/gwt/ss/client/GwtAccessDeniedException.html GwtAccessDeniedException] 通知.
<br/><span color="red">(Notice: previous proxy-target-class must be set to "false")</span>
{{{
    <beans:bean class="com.gwt.ss.GwtSessionManagement"/>
}}}